// This file was generated by Mendix Modeler.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the code between BEGIN USER CODE and END USER CODE
// Other code you write will be lost the next time you deploy the project.

import ReactNative from "react-native";
import ImagePickerLib from "react-native-image-picker";

type PictureSource = "camera" | "imageLibrary" | "either";

/**
 * @param {MxObject} image - Required
 * @param {Big} targetWidth - Defaults to 150
 * @param {Big} targetHeight - Defaults to 150
 * @param {"Actions.PictureSource.camera"|"Actions.PictureSource.imageLibrary"|"Actions.PictureSource.either"} pictureSource - Defaults to "either"
 * @returns {boolean}
 */
function SelectImage(
    image?: mendix.lib.MxObject,
    targetWidth?: BigJs.Big,
    targetHeight?: BigJs.Big,
    pictureSource?: PictureSource
): Promise<boolean> {
    // BEGIN USER CODE
    // Documentation https://github.com/react-native-community/react-native-image-picker/blob/master/docs/Reference.md

    const ImagePicker: typeof ImagePickerLib = require("react-native-image-picker");

    if (!image) {
        throw new TypeError("Input parameter 'image' is required");
    }

    if (!image.inheritsFrom("System.FileDocument")) {
        const entity = image.getEntity();
        throw new TypeError(`Entity ${entity} does not inherit from 'System.FileDocument'`);
    }

    return takePicture()
        .then(uri => {
            if (uri) {
                return storeFile(image, uri);
            }
            return Promise.resolve(false);
        })
        .catch(error => {
            if (error !== "canceled") {
                throw new Error(error);
            }
            return Promise.resolve(false);
        });

    function takePicture(): Promise<string | undefined> {
        return new Promise((resolve, reject) => {
            const options = getOptions();
            const method = getPictureMethod();

            method(options, response => {
                if (response.didCancel) {
                    return resolve();
                }

                if (response.error) {
                    const unhandledError = handleImagePickerError(response.error);
                    if (!unhandledError) {
                        return resolve();
                    }
                    return reject(response.error);
                }

                return resolve(response.uri);
            });
        });
    }

    function storeFile(imageObject: mendix.lib.MxObject, uri: string): Promise<boolean> {
        return new Promise((resolve, reject) => {
            fetch(uri)
                .then(res => res.blob())
                .then(blob => {
                    const guid = imageObject.getGuid();
                    const filename = /[^\/]*$/.exec(uri)![0];

                    mx.data.saveDocument(guid, filename, {}, blob, onSuccess, onError);

                    function onSuccess(): void {
                        const Alert: typeof ReactNative.Alert = require("react-native").Alert;
                        Alert.alert("Success", filename);
                        resolve(true);
                    }

                    function onError(e: Error): void {
                        reject(e.message);
                    }
                })
                .catch(error => reject(error));
        });
    }

    // tslint:disable-next-line:typedef
    function getPictureMethod() {
        const source = pictureSource ? pictureSource : "either";

        switch (source) {
            case "either":
                return ImagePicker.showImagePicker;
            case "imageLibrary":
                return ImagePicker.launchImageLibrary;
            case "camera":
                return ImagePicker.launchCamera;
        }
    }

    // tslint:disable-next-line:typedef
    function getOptions() {
        const maxWidth = targetWidth ? Number(targetWidth.toString()) : 150;
        const maxHeight = targetHeight ? Number(targetHeight.toString()) : 150;

        return {
            mediaType: "photo" as "photo",
            maxWidth,
            maxHeight,
            noData: true,
            permissionDenied: {
                title: `This app does not have access to your camera or photos`,
                text: "To enable access, tap Settings > Permissions and turn on Camera and Storage.",
                reTryTitle: "Settings",
                okTitle: "Cancel"
            }
        };
    }

    function handleImagePickerError(error: string): string | undefined {
        const ERRORS = {
            AndroidPermissionDenied: "Permissions weren't granted",
            iOSPhotoLibraryPermissionDenied: "Photo library permissions not granted",
            iOSCameraPermissionDenied: "Camera permissions not granted"
        };

        switch (error) {
            case ERRORS.iOSPhotoLibraryPermissionDenied:
                showiOSPermissionAlert(
                    "This app does not have access to your photos or videos",
                    "To enable access, tap Settings and turn on Photos."
                );
                return;

            case ERRORS.iOSCameraPermissionDenied:
                showiOSPermissionAlert(
                    "This app does not have access to your camera",
                    "To enable access, tap Settings and turn on Camera."
                );
                return;

            case ERRORS.AndroidPermissionDenied:
                // Ignore this error because the image picker plugin already shows an alert in this case.
                return;

            default:
                return error;
        }
    }

    function showiOSPermissionAlert(title: string, message: string): void {
        const Alert: typeof ReactNative.Alert = require("react-native").Alert;
        const Linking: typeof ReactNative.Linking = require("react-native").Linking;

        Alert.alert(
            title,
            message,
            [
                { text: "Cancel", style: "cancel" },
                { text: "Settings", onPress: () => Linking.openURL("app-settings:") }
            ],
            { cancelable: false }
        );
    }

    // END USER CODE
}
